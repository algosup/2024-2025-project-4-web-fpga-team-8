# Test Cases

## Overview          

This document will gather all the test cases written by the quality assurance. They would be sorted into four different categories which are:


You can also find all these test cases on a Google Spreadsheet at this [link](https://docs.google.com/spreadsheets/d/1B7zPvFrQOAbfDn83oj7oqQtqf9ijVUlLKgUKdX3Rr5A/edit?gid=0#gid=0)

## Priority 

The following test cases would be assigned a priority from high to medium following the underneath table:

| number | Priority |
| ------ | -------- |
| 1      | High     |
| 2      | Medium   |
| 3      | Low      |

## Backend Tests (Manual Testing)
##### Test Case 1

| Test Case ID    | TC_001                                                                                                                                                                                                                                                   |
| --------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Test Title      | Upload Valid Verilog File – Successful Processing                                                                                                                                                                                                        |
| Objective       | Verify that a valid Verilog file can be uploaded and processed by the backend without errors.                                                                                                                                                            |
| Prerequisites   | - backend server is running                                                                                                                                                                                                                              |
| Steps           | - A sample file (e.g `verilog module.v`) is prepared to upload                                                                                                                                                                                           |
| Expected Result | The upload is accepted with an HTTP 200 OK response. The server processes the file without errors and returns a success confirmation or parsed result. The file content is now stored/available for further operations (e.g., parsing or visualization). |
| Status          | -                                                                                                                                                                                                                                                        |
| Notes           | This is the happy path for file uploads, ensuring the system can handle correct input as expected.                                                                                                                                                       |
##### Test Case 2

| Test Case ID    | TC_002                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| --------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Test Title      | Upload Invalid Verilog Files – Error Handling                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| Objective       | Ensure the backend rejects invalid file uploads (wrong format, empty file, or missing data) and responds with appropriate errors.                                                                                                                                                                                                                                                                                                                                                                                                              |
| Prerequisites   | - Backend server is running.  <br>- Prepare a set of invalid files: (a) a file with an unsupported format (e.g., `sample.txt`), (b) an empty Verilog file (0 bytes or no content), (c) a Verilog file with missing essential sections (e.g., missing module declaration or endmodule).                                                                                                                                                                                                                                                         |
| Steps           | 1. Attempt to upload the unsupported format file (e.g. `sample.txt`) via the upload API.  <br>2. Observe the response for any error message or code.  <br>3. Attempt to upload the empty Verilog file in the same way.  <br>4. Observe the response for errors.  <br>5. Attempt to upload the malformed Verilog file (missing fields).  <br>6. Observe the response for errors.                                                                                                                                                                |
| Expected Result | In each case, the backend should reject the file and **not** process it. An error response (HTTP 4xx) is returned for each attempt:  <br>- Wrong format: e.g., HTTP 415 Unsupported Media Type or 400 Bad Request, with a message like "Invalid file format."  <br>- Empty file: e.g., HTTP 400 Bad Request, with a message "File is empty or no content."  <br>- Malformed file: e.g., HTTP 400 Bad Request, with a message indicating a parse error or "Invalid Verilog content."  <br>No file data is stored in the system for these cases. |
| Status          | -                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| Notes           | This test covers multiple negative scenarios to ensure robust validation on upload. The server should handle each gracefully without crashing.                                                                                                                                                                                                                                                                                                                                                                                                 |
##### Test Case 3

| Test Case ID    | TC_003                                                                                                                                                                                                                                                                                                                                                                                                |
| --------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Test Title      | Server Response on File Upload Error                                                                                                                                                                                                                                                                                                                                                                  |
| Objective       | Confirm that when a file upload fails (due to invalid input), the server’s error response is formatted correctly and meaningful.                                                                                                                                                                                                                                                                      |
| Prerequisites   | - Backend server is running.  <br>- An invalid file (from TC002 prerequisites) is ready to use for triggering an error (e.g., `empty.v` or `sample.txt`).                                                                                                                                                                                                                                             |
| Steps           | 1. Upload an invalid file (for example, the empty Verilog file) using the API.  <br>2. Capture the server’s HTTP response code and message/body.                                                                                                                                                                                                                                                      |
| Expected Result | The server returns an appropriate error code (e.g., 400 Bad Request). The response body contains a clear error message (in JSON or plaintext) explaining the issue (for example, `{"error": "No content in file"}` or a similar structured error). The format of the error response should follow the API's error response conventions (e.g., a JSON with an "error" field or a specific error code). |
| Status          | -                                                                                                                                                                                                                                                                                                                                                                                                     |
| Notes           | This test focuses on verifying the **content and format** of error responses, not just the code. It ensures clients receive useful feedback on why the upload failed.                                                                                                                                                                                                                                 |
##### Test Case 4

| Test Case ID    | TC_004                                                                                                                                                                                                                                                                                                                                    |
| --------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Test Title      | Verilog Parsing – Module Name and I/O Extraction                                                                                                                                                                                                                                                                                          |
| Objective       | Ensure that the backend parser correctly extracts module names and their input/output signals from a valid Verilog file.                                                                                                                                                                                                                  |
| Prerequisites   | - Backend server is running and able to parse files.  <br>- A known good Verilog file with a clearly defined module (e.g., `example_module.v` with known inputs/outputs) is uploaded or available.                                                                                                                                        |
| Steps           | 1. Trigger the parsing function for `example_module.v` (this might happen automatically on upload or via a specific parse API call).  <br>2. Retrieve the parse results (for example, via an API response or by checking the returned JSON data).  <br>3. Inspect the results for the module’s name and list of input and output signals. |
| Expected Result | The parsed data includes the module’s name exactly as defined in the Verilog file, and lists all input and output ports of that module. Each input/output in the file should appear in the parsed output. No extra or missing signals should be present, and their classifications (input vs output) should be correct.                   |
| Status          | -                                                                                                                                                                                                                                                                                                                                         |
| Notes           | If the file contains multiple modules, each should be parsed. This test can be repeated for each module, but primarily focuses on one module for clarity.                                                                                                                                                                                 |
##### Test Case 5

| Test Case ID    | TC_005                                                                                                                                                                                                                                                                                                                                                                                     |
| --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Test Title      | Verilog Parsing – BEL Type Detection (Flip-Flops and LUTs)                                                                                                                                                                                                                                                                                                                                 |
| Objective       | Verify that the parser identifies basic logic elements (BELs), specifically Flip-Flops and LUTs, within the Verilog design.                                                                                                                                                                                                                                                                |
| Prerequisites   | - Backend server is running with parsing capability.  <br>- A Verilog file that instantiates or infers flip-flops and LUTs (e.g., includes registers that become flip-flops and combinatorial logic that would map to LUTs) is uploaded/available.\|                                                                                                                                       |
| Steps           | 1. Parse the prepared Verilog file that contains flip-flop(s) and LUT logic.  <br>2. After parsing, examine the output data (JSON or other format) for entries corresponding to logic elements.  <br>3. Identify in the output where flip-flops and LUTs are listed or categorized.                                                                                                        |
| Expected Result | The parsing output should clearly indicate the presence of flip-flops and LUTs. For example, flip-flop elements (registers) might be labeled or counted in a section of the JSON (such as `"BELs": { "flipFlops": [...] }`) and LUTs similarly labeled (e.g., `"LUTs": [...]`). Each flip-flop and LUT in the Verilog source should appear in the output data with correct identification. |
| Status          | -                                                                                                                                                                                                                                                                                                                                                                                          |
| Notes           | This ensures the parser not only reads structural info (modules and ports) but also recognizes specific hardware primitives or inferred elements crucial for visualization.                                                                                                                                                                                                                |
##### Test Case 6

| Test Case ID    | TC_006                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Test Title      | Verilog Parsing – JSON Output Structure Verification                                                                                                                                                                                                                                                                                                                                                                                                   |
| Objective       | Validate that the JSON output produced by the parser is well-structured and contains all expected fields and sections.                                                                                                                                                                                                                                                                                                                                 |
| Prerequisites   | - Backend server is running.  <br>- A Verilog file has been parsed, and its JSON result is obtainable (either returned via API or saved on the server).  <br>- The expected JSON schema/structure is known (or a reference output from a correct parse is available).                                                                                                                                                                                  |
| Steps           | 1. Parse a sample Verilog file to produce a JSON output (if not already done in a previous test).  <br>2. Retrieve the JSON output from the server (via an API call or file system, as appropriate).  <br>3. Examine the JSON for the presence of key sections (e.g., module definitions, signals, connections, BELs, etc.).  <br>4. If a schema or reference structure is defined, compare the output against it to ensure compliance.                |
| Expected Result | The JSON output is properly formatted (well-formed JSON) and includes all necessary sections. For example, it should have entries for modules, their I/Os, any internal connections or nets, lists of flip-flops/LUTs, and other relevant data for visualization. No expected field should be missing or null (unless intentionally empty), and the hierarchy (nested objects/arrays) should make logical sense corresponding to the design structure. |
| Status          | -                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| Notes           | This test is about output format integrity. It helps ensure that front-end components (which consume this JSON) will receive data in the correct format and won't break due to missing fields or structure changes.                                                                                                                                                                                                                                    |
#### File Retrieval tests
##### Test Case 7

| Test Case ID    | TC_007                                                                                                                                                                                                                                                                                                                                                         |
| --------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Test Title      | File Retrieval – Download Uploaded File Successfully                                                                                                                                                                                                                                                                                                           |
| Objective       | Ensure that an uploaded Verilog file can be fetched via the backend API and that it is served correctly and intact.                                                                                                                                                                                                                                            |
| Prerequisites   | - Backend server is running.  <br>- At least one Verilog file has been uploaded successfully (use the file from TC001 or upload a new file, obtaining its file ID or reference).                                                                                                                                                                               |
| Steps           | 1. Send a GET request to the file retrieval endpoint (e.g., `/api/files/{fileId}`) for a known existing file.  <br>2. Receive the response from the server containing the file data.  <br>3. Check the HTTP status code of the response (should be 200 OK).  <br>4. Verify the content of the returned file matches the original file’s content byte-for-byte. |
| Expected Result | The server returns HTTP 200 OK and the body of the response contains the exact file content that was uploaded. The file is served with the correct content type (e.g., `application/octet-stream` or a specific type for Verilog files) and no data is corrupted or altered. The file name may be present in headers (Content-Disposition) if applicable.      |
| Status          | -                                                                                                                                                                                                                                                                                                                                                              |
| Notes           | This ensures that files stored on the server can be retrieved by users. It also implicitly checks that uploads were actually saved. If multiple files exist, this test can be repeated for a sampling of them.                                                                                                                                                 |
##### Test Case 8

| Test Case ID    | TC_008                                                                                                                                                                                                                                                                                                                                                                      |
| --------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Test Title      | File Retrieval – Non-existent File Handling                                                                                                                                                                                                                                                                                                                                 |
| Objective       | Verify the backend’s response when a client requests a file that does not exist or an incorrect file path.                                                                                                                                                                                                                                                                  |
| Prerequisites   | - Backend server is running.  <br>- Determine a file ID or filename that is invalid or not present (e.g., a random GUID or an ID number higher than any uploaded file, ensuring it doesn't exist).                                                                                                                                                                          |
| Steps           | 1. Send a GET request to the file retrieval endpoint for a non-existent file (e.g., `/api/files/99999` if that ID is not used).  <br>2. Observe the server’s response code and message.                                                                                                                                                                                     |
| Expected Result | The server should return a clear error for missing files. The expected HTTP status is 404 Not Found (if the file ID is not present) or 400 Bad Request (if the request format is invalid). The response body should contain an error message such as "File not found" or "Invalid file identifier." The server must handle this gracefully (no crash, and timely response). |
| Status          | -                                                                                                                                                                                                                                                                                                                                                                           |
| Notes           | This test confirms proper error handling for resource retrieval. It can be extended to test variations (e.g., asking for a file with an invalid format ID like a string where number is expected, to ensure 400 vs 404 distinctions).                                                                                                                                       |
#### Error Handling Tests
##### Test Case 9

| Test Case ID    | TC_009                                                                                                                                                                                                                                                                                                            |
| --------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Test Title      | Error Handling – Missing File in Request                                                                                                                                                                                                                                                                          |
| Objective       | Ensure that the backend returns a proper error when a required file input is missing from a request (for example, calling a parse or visualize endpoint without providing a file).                                                                                                                                |
| Prerequisites   | - Backend server is running.  <br>- Identify an endpoint that requires a file (e.g., an API for parsing or starting visualization) and how it expects the file to be provided (file upload field, file ID, etc.).                                                                                                 |
| Steps           | 1. Invoke the parsing/processing API without including the file (e.g., omit the file upload field or file ID parameter in the request).  <br>2. Observe the server’s HTTP response and message.                                                                                                                   |
| Expected Result | The server should detect the missing file input and respond with an error. Typically, this would be an HTTP 400 Bad Request with a message like "No file provided" or "Missing required file parameter." The error should be handled gracefully (no exception dumps in the response, just a clean error message). |
| Status          | -                                                                                                                                                                                                                                                                                                                 |
| Notes           | This test verifies input validation on the backend. It ensures that if a user mistakenly submits a request without a file, the system responds with a clear message rather than failing unpredictably.                                                                                                            |
##### Test Case 10

| Test Case ID    | TC_0010                                                                                                                                                                                                                                                                                                                                                     |
| --------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Test Title      | Error Handling – Corrupted Verilog File Parsing                                                                                                                                                                                                                                                                                                             |
| Objective       | Verify that the backend can handle a corrupted or syntactically invalid Verilog file by reporting an error instead of failing silently or crashing.                                                                                                                                                                                                         |
| Prerequisites   | - Backend server is running.  <br>- A corrupted/invalid Verilog file is prepared (e.g., a file with syntax errors, such as missing `endmodule` or random binary content with `.v` extension).                                                                                                                                                               |
| Steps           | 1. Upload or send the corrupted Verilog file to the parse endpoint.  <br>2. Monitor the server’s response and any error logs for the parsing process.                                                                                                                                                                                                       |
| Expected Result | The server should gracefully handle the parse error. The response should be an error indication (likely HTTP 400) with a message describing the failure (for example, "Parse error at line X" or "Invalid Verilog syntax"). The system should not crash or hang – it should catch the parse exception and return control to the client with the error info. |
| Status          | -                                                                                                                                                                                                                                                                                                                                                           |
| Notes           | This simulates a user uploading a bad file. It tests the robustness of the parsing logic and error messaging, ensuring even malformed input won’t break the system.                                                                                                                                                                                         |
##### Test Case 11

| Test Case ID    | TC_0011                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| --------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Test Title      | API Response Codes – Invalid Input Scenarios                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| Objective       | Confirm that each type of invalid request to the backend yields the correct HTTP response code and message, in line with the API specification.                                                                                                                                                                                                                                                                                                                                                                                                                               |
| Prerequisites   | - Backend server is running.  <br>- A list of expected error scenarios and their intended HTTP codes is known (or defined by the API design). For example: invalid file format → 415, not found → 404, validation error → 400, etc.                                                                                                                                                                                                                                                                                                                                           |
| Steps           | 1. Perform a series of invalid operations, each designed to trigger a specific error condition:  <br>  a. Upload an unsupported file type (triggering format error).  <br>  b. Request a missing file (triggering 404 not found).  <br>  c. Omit required parameters in a request (triggering validation error).  <br>  d. (Any other relevant error scenario).  <br>2. For each operation, record the HTTP status code and error message returned by the server.                                                                                                             |
| Expected Result | Each scenario should return the **documented HTTP status code** and a meaningful error message. For instance:  <br>- Unsupported file type → **415 Unsupported Media Type** (if used) or **400 Bad Request**, with message "Unsupported file format."  <br>- Missing file (not found) → **404 Not Found**, "File not found."  <br>- Missing parameter → **400 Bad Request**, "Required parameter X is missing."  <br>No scenario should return a generic 500 Internal Server Error for handled cases; all errors should be anticipated and return a controlled response code. |
| Status          | -                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| Notes           | This test consolidates verification of error handling consistency. It ensures the API is user-friendly and follows RESTful practices for error responses, making it easier for front-end or API clients to interpret failures.                                                                                                                                                                                                                                                                                                                                                |

## Frontend Tests (Vitest)
##### Test Case 12

| Test Case ID    | TC_0012                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| --------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Test Title      | UI Text and Content Verification                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Objective       | Ensure all user-facing text in the application is correct (no typos, proper grammar) and that UI labels and descriptions match their functionality.                                                                                                                                                                                                                                                                                                             |
| Prerequisites   | - The frontend application is built and ready for testing.  <br>- Access to all pages/components of the UI (either via a running app or by rendering components in tests).                                                                                                                                                                                                                                                                                      |
| Steps           | 1. Navigate through each page of the application (e.g., Home, File Upload, Visualization view, Controls) or render them in a test environment.  <br>2. Check all visible text elements on each page (titles, button text, labels, tooltips, instructions).  <br>3. Verify spelling and grammar for each text element.  <br>4. Verify that each label/description clearly corresponds to its function (e.g., a button labeled "Upload" initiates a file upload). |
| Expected Result | All text in the UI is free of spelling and grammatical errors. The language is clear and professional. Every label and description correctly describes its purpose (no mislabeled buttons or confusing instructions). For example, simulation control buttons should be named intuitively ("Play", "Pause", etc.), and any help text should be coherent.                                                                                                        |
| Status          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| Notes           | This is largely a visual/manual verification, but some aspects could be automated with snapshot tests or by checking component text in Vitest. It ensures a polished user experience.                                                                                                                                                                                                                                                                           |
##### Test Case 13

| Test Case ID    | TC_0013                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Test Title      | Frontend-Backend Integration – Fetch Example Verilog File                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| Objective       | Verify that the frontend correctly calls the backend API to fetch example Verilog files and handles the response properly.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| Prerequisites   | - The backend API for example files is available (or mocked).  <br>- The frontend code has functionality to load example files (e.g., on page load or via an "Load Example" button).                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| Steps           | 1. Simulate the action that triggers fetching an example file (this could be navigating to the page that auto-loads an example or clicking a "Load Example" UI control).  <br>2. In the test, intercept or mock the network request to the example files API endpoint.  <br>3. Provide a dummy example file response (if mocking) or ensure a real response is returned from a dev server.  <br>4. Verify that the frontend makes a request to the correct URL.  <br>5. Verify that once the response is received, the frontend stores or displays the example file content (e.g., populating a code editor area or updating state). |
| Expected Result | The frontend should successfully retrieve the example file data. This means the network call is made (observed via mock or dev tools) and returns a 200 OK. The example file’s content (or name) is then visible in the UI: for instance, the code editor area might show the Verilog code of the example, or a file list dropdown is populated with example file names. There should be no errors in the console or failed network calls.                                                                                                                                                                                           |
| Status          | -                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| Notes           | In a Vitest environment, this can be tested with a mocked fetch. It ensures the integration point (frontend requesting data from backend) works as expected.\|                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
##### Test Case 14

| Test Case ID    | TC_0014                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| --------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Test Title      | Frontend Data Display – Parsing Results Rendering                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Objective       | Ensure that when the backend returns parsed data (JSON) for an uploaded or selected Verilog file, the frontend displays the results correctly in the UI.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| Prerequisites   | - The frontend is able to receive parse results from the backend (either via a direct response to an upload or a separate fetch).  <br>- A sample parsed JSON result is available (from a real parse or a mocked response) corresponding to a known Verilog file.                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Steps           | 1. Trigger a file parse flow from the frontend: e.g., simulate uploading a file or using the example file loaded in TC013 and then initiating its parsing/visualization.  <br>2. Mock or capture the backend’s parsed JSON response (if using a real backend, ensure it returns the expected data for the file).  <br>3. Allow the frontend logic to process this parsed data (which might include setting state for the visualization or populating certain UI components like lists of modules or signals).  <br>4. Check the UI for the presence of information derived from the parsed data: for instance, the module name might be displayed somewhere, or a list of I/O signals, or a confirmation that parsing succeeded. |
| Expected Result | The frontend correctly reflects the parsed file's information. For example, if the JSON contains a module "top_module" with inputs "a, b" and output "y", the UI might show "Module: top_module" and list inputs a, b and output y in the appropriate section. Any visual elements that depend on the parsed data (like the FPGA grid highlighting certain components) should now be initialized (though those are tested in visualization-specific cases). No errors should occur during this process.                                                                                                                                                                                                                          |
| Status          | -                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Notes           | \|This test can be implemented as a component/unit test verifying state changes after a mock parse result is committed. It ensures the front-end correctly interprets backend data.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
##### Test Case 15

| Test Case ID    | TC_0015                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| --------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Test Title      | Visualization Interaction – Zoom and Pan Functionality                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| Objective       | Verify that the FPGA layout visualization supports zooming in/out and panning, and that these interactions update the view appropriately.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| Prerequisites   | - Frontend is displaying an FPGA layout (the visualization component is loaded with some data, e.g., after parsing a file).  <br>- The visualization component's methods or state for zoom level and position can be accessed or simulated.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| Steps           | 1. Simulate a **zoom in** action. This could be done by programmatically calling the zoom-in function or dispatching a scroll/gesture event in the test environment.  <br>2. Verify that the visualization's zoom level increased (check a state variable or the rendered element dimensions/scaling).  <br>3. Simulate a **zoom out** action (similarly, via function or event).  <br>4. Verify the zoom level decreased accordingly.  <br>5. Simulate a **pan** action by programmatically adjusting the view (for example, calling a pan function or simulating click-and-drag events).  <br>6. Verify the visualization’s viewport shifted (check that the portion of the FPGA shown has moved, e.g., via changed offset coordinates or visible element positions). |
| Expected Result | Zooming in makes the FPGA elements appear larger (zoom factor increases), and zooming out makes them smaller, within allowed limits (no infinite zoom or negative scale). Panning moves the view horizontally/vertically without refreshing or errors — the user can navigate to different parts of the FPGA diagram. Throughout these interactions, the application state updates consistently (for instance, a zoom level state variable matches the user action) and no graphical glitches or console errors occur.                                                                                                                                                                                                                                                  |
| Status          | -                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| Notes           | This can be partially tested with unit tests by calling the zoom/pan logic directly. Full manual testing might be needed to ensure smoothness, but the state changes and boundaries (min/max zoom, pan limits) can be verified programmatically.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
##### Test Case 16

| Test Case ID    | TC_0016                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Test Title      | Visualization Accuracy – Signal Propagation Animation                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| Objective       | Validate that the signal propagation is animated correctly on the FPGA visualization, reflecting the correct path and timing of signals.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| Prerequisites   | - A loaded design in the visualization that includes a known signal path (e.g., an input that drives a LUT which drives a flip-flop).  <br>- The simulation/playback can be started (either manually or via a function call in tests).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| Steps           | 1. Start the signal propagation simulation (e.g., click "Play" or call the function that begins the animation).  <br>2. Observe the visualization (or in a test, track the state changes) as the simulation runs. Identify a particular signal or path to follow (for example, a known critical path or a test signal injected).  <br>3. Verify that when the signal is activated at its source (e.g., an input goes high), the corresponding visual element (say the input block) highlights at that time.  <br>4. Continue to verify that downstream elements along that signal's route highlight in the correct sequence and at the correct simulation time steps (for instance, the LUT that the signal feeds lights up next, then the flip-flop, etc.).  <br>5. If possible, use a step-by-step simulation (pause and step through frames) to check the order of activation on each relevant component. |
| Expected Result | The signal animation follows the logical connectivity of the circuit. Each segment of the path is highlighted only when the signal actually propagates there in time. There should be no skips (e.g., an intermediate node lighting up out of order) and no missing highlights (every connection that should carry the signal does highlight). The timing of the highlights should correspond to the simulation clock or sequence – for example, if there's a one-cycle delay through a flip-flop, the highlight on its output appears one step after the input.                                                                                                                                                                                                                                                                                                                                             |
| Status          | -                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| Notes           | This test may be difficult to fully automate; however, the logic that controls animation timing can be unit-tested by simulating clock ticks. Visual verification is important to ensure the user sees a correct animation.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
##### Test Case 17

| Test Case ID    | TC_0017                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Test Title      | Playback Controls – Play, Pause, Resume, Step Operations                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| Objective       | Ensure that the simulation playback controls work correctly: Play starts the simulation, Pause halts it, Resume continues, and Step advances it incrementally.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| Prerequisites   | - A loaded simulation ready to run (post-parsing and with data to simulate).  <br>- The frontend provides controls (buttons or UI elements) for play, pause, resume, and stepping. In a test environment, these controls can be invoked programmatically.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| Steps           | 1. Click or trigger **Play**. (In a test, call the function that starts the simulation or simulate a button press.)  <br>2. Verify that the simulation state changes to "running" (e.g., a playing flag is true, or frames start updating in the visualization).  <br>3. After a short duration, trigger **Pause**.  <br>4. Verify the simulation state is now "paused" (e.g., no new frame updates, a paused flag is true, or a current time index stops incrementing).  <br>5. Trigger **Resume** (which may be the same as Play if using a toggle, or a separate resume button/control).  <br>6. Verify the simulation picks up from where it left off (the state continues advancing from the paused point, not from the beginning).  <br>7. Trigger the **Step** function/button to advance one simulation increment while paused.  <br>8. Verify that the simulation advanced by one step (e.g., the visualization shows the next state, and then remains paused again). |
| Expected Result | The Play control successfully starts the simulation animation. The Pause control stops the progression immediately. Resume continues the simulation without resetting the state. The Step control moves the simulation forward by exactly one frame/tick and then stops, allowing frame-by-frame analysis. The UI should reflect the state (for example, Play may become disabled or change to a "Resume" icon when paused, etc.). No control should cause erratic behavior (e.g., multiple rapid clicks should not break the state machine of the player).                                                                                                                                                                                                                                                                                                                                                                                                                    |
| Status          | -                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| Notes           | This can be tested with Vitest by checking state variables and perhaps using fake timers to simulate time progression. It ensures the user can control the playback as expected.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
##### Test Case 18

| Test Case ID    | TC_0018                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Test Title      | Playback Controls – Simulation Speed Settings (1x, 2x, 4x)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Objective       | Verify that the simulation playback speed can be adjusted (e.g., normal, 2×, 4×) and that it affects the animation timing appropriately.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| Prerequisites   | - A running or ready-to-run simulation in the frontend.  <br>- Controls (buttons or dropdown) to select simulation speed. These should be accessible in the test context.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| Steps           | 1. Start the simulation at normal speed **1×** (default). Note the approximate interval between state updates or frames (this could be observed via a counter or console logs if provided).  <br>2. Switch the speed to **2×** while the simulation is running (simulate selecting the 2× option).  <br>3. Verify that the rate of visual updates has roughly doubled (for instance, if frames were every 1 second, they are now ~0.5 seconds apart).  <br>4. Switch the speed to **4×**. Verify the update rate is approximately four times the original speed (frames ~0.25 seconds apart, continuing the analogy).  <br>5. (Optional) Switch back to **1×** to see if the simulation returns to normal speed smoothly. |
| Expected Result | Changing the speed dynamically adjusts the simulation’s playback rate. At 2×, the propagation animation proceeds twice as fast as at 1×; at 4×, four times as fast. The transitions between speeds should not cause resets or jumps in the simulation; the system should simply start using a different timing interval. The visual result is a faster or slower animation, and if the user switches speeds, the simulation continues correctly at the new rate.                                                                                                                                                                                                                                                          |
| Status          | -                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| Notes           | If implementing in Vitest, you might simulate this by checking that a timer interval or delay value in state changes when speed is changed. Visually, one would confirm the effect, but logically the code should reflect the correct multiplier on speed.                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
